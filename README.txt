Tic-Tac-Toe On-line
By: Abhishek Thakare (ayt17) and Adhit Thakur (at1186)


Contents
This README discusses the processes behind the project “Tic-Tac-Toe On-line” 120 point version, which involves creating the game Tic-Tac-Toe for two players with multiple games and interruptions, with designated X’s and O’s. The ending conditions of this game are: 
* One player wins by placing 3 marks in a single row, column, or diagonal
* Both players draw by filling the board without either player winning
* One player resigns
* Both players agree to draw
Our goal is to implement a server-client protocol where each client can communicate and send messages to each other through the server about the status of the players and the game. The messages that are sent include showing the current state of the grid, showing what moves the players have made, and when it is a client’s turn to play. The ttts.c file represents the server, while the ttt.c file represents the client side. The ttts file is run by running the make file (“make clean” then “make”, and then running ttts with an argument indicating the port number you would like to run the server on (for example ./ttts 16444 to run on port 16444)). After this, ttt is run by indicating the domain name and port number (for example on wax.cs.rutgers.edu ttt would be run using ./ttt wax.cs.rutgers.edu 16444). Based on the specific actions occurring in the game, the server and client will display messages to indicate the game status. In this README, we will go over our test plan, our test programs, and any additional design notes we feel are needed for the understanding of this project.
Design Notes
When working on this project, the steps for completing each component were broken up by the point divisions provided in the write-up. 
Part 1: Planning out the project
* When brainstorming ideas for the game, we realized that data organization was a key component which allowed for smooth progression from single game to multiple game mode. Because of this, we decided to use a Game structure, which contained two Client structures and other data that would be used later on to perform various functions such as writing (socket descriptors) or changing state (from waiting to playing to being in draw request). Besides this, we wanted each connection or Client to have its own thread, meaning that per game, there were two threads. These threads would communicate through the server by using the member variables of the Game structure. We felt like creating a thread for each Client would make multiple games a concept of matching threads. 
Part 2: Getting the code to work for a single game
* For single game mode, we used two connections to the server and created a thread function for each connection. This is because while player one and player two had some of the same major functionalities, there were some key differences. Our logic of the code makes it so that in the Game structure, the client which connects to the server first is player one, and the second connection is player two. Player one always has to type PLAY before player two, and if player two tries to type anything, they are prompted to wait. After both users have clicked play, either user can go first, and once a move has been made, the turn variable in the Game structure alternates. The game grid is outputted to both players each time a move is made, and invalid messages are sent when necessary. This implementation allowed for turns to be made and checked efficiently. We kept the logic so that player one had to enter PLAY first because we felt like it made sense to establish some order in this sense.
* In the thread functions themselves, there was an infinite read loop run on the respective socket descriptor, which read in what the client entered. After this, the line was split up into words and the commands were interpreted from there. One concept that was realized was how often, finding out edge cases related to a command was more difficult than the actual command implementation. A bug that was encountered related to a fond old enemy, pointer arithmetic and assigning. The assignment of structure pointers to our thread functions and within the structures themselves were incorrect, and it took us a while to realize this error and figure out how to correct it. One action that made the process of completing this mode more procedural was using debug statements and testing the game out, since after a single functionality or edge case was implemented, it would simply be checked by running the game or printing out variables used. This saved us a lot of time in terms of error handling. 
Part 3: Getting the code to work for multiple games
* Once we figured out how to implement a single game, our data organization allowed for multiple games to just be based on that. We created a global array of games (of fixed size), initialized this, and looped through the array and checked for if there was a game with only one client in it. If there was a game with only one client or player, then that new connection was added to that Game structure and the game was started, but if there was no game with one connection, then the new connection was added to a new game. Because of each player having its own thread run, this was all that was needed for multiple games. 
Part 4: Finishing up the extra credit portion of Drawing and Resigning
* For Drawing and Resigning, we did not use signals. Instead, we used the same formatting as we did for checking the existence of commands such as PLAY or MOVE, but for DRAW S and RESIGN. If DRAW S was entered, a message would be sent to the other player, a status variable would be updated, and the other player would have to enter in an A or R to say whether they accept or reject the draw request. If A was clicked, then the game was finished, if not, the game continued on. Because there was a thread running for each client and a turn system established, we were able to send a message to another player while it was blocking. 
* Resigning was interpreting the RESIGN command, and if this command was entered then the game would just shut down. 
* We also added a global names array which was used to check if a given name was already used or not, so there was uniqueness in the player names
* Below is a model that describes our design (this model will be attached with the project since it does not appear in .txt format)


In this model, the design process and flow can be seen. There is a thread pool (listener), which takes in connections, and the game matcher (main thread), which matches threads together and puts them into a game at a certain index in the games list. The read thread symbol can be seen as just being accepted as a connection and then being paired with a game with only one connection at games[4]. After Game structures are filled, then the games are played, and once the game is done, the Game structure is “recycled” or reset at its respective position in the game list, so that it can be used again by another pair of players who join. If a player interrupts the game and requests a draw that is eventually accepted or resigns, then the game ends abruptly, the threads are destroyed, and the game structure is recycled (as can be seen by the orange thread). If a game proceeds as normal, then the threads are ended and game structure is recycled as well. 


Test Plan
Talk about what we knew we did for each game component, and how it connects to what the writeup says/what we did in class
Single game
* For the single game mode, we tested by constantly debugging and printing different variables every time some progress was made. We also tested by running the game and testing the edge case or game feature that we added in game. By making sure that each step of the development process was thoroughly tested, we made sure that we did not encounter any deeply embedded errors later on in the process. Besides this, we made a list and simply tried playing the game as a player to see if any component would break to ensure that all parts were test-proof. 
Multiple concurrent games:
* For testing multiple games, we knew that there were three cases, with these being if there was no game in a structure, if there was one game in a structure, or if there was no game in a structure and this structure was later on in the games array. We tested the multiple games feature by running a multitude of games at once and playing them at the same time, one by one, and by ending certain games and reconnecting back to the server to see if there were any faults in connection. Once again, a good portion of the testing here was done by just playing the game and typing different variations of commands to see what would break the code. 
Drawing and Resigning:
* The testing for the RESIGN command was straightforward, since it required a single command being entered and that leading to the game ending. We awarded the victory to the player who did not resign, and tested this functionality by having a player RESIGN in a game and then creating a new game. 
* The DRAW S command had different cases, with these being if a player requests and it is accepted, and a player requests and it is rejected. Depending on these cases, we produced different outcomes, with accept’s outcome being to continue the game and reject’s to be shutting down the game. One semi-faulty feature we have is when a player requests a DRAW and the other player rejects it, there may be an invalid command message printed and enter may need to be pressed for there to be no invalid message that appears, but the main functionality for resign is still there and works in an efficient manner. 


Test Programs
In terms of testing our files, we created a ttt.c file to act as a client, that way we can play our Tic Tac Toe game and check for any bugs or errors. Our ttts.c file contains all the code for the server side and how it interacts with the clients, so once we find a bug with how the game is working, we easily know where to look in our ttts.c file to fix the error. With ttts.c, we are able to create multiple clients, approximately 256 at maximum. This helps us with testing out multiple games to see if we run into any multithreading issues or bugs with the Tic Tac Toe game itself. This was our main approach to running tests in our game to see if it is working properly according to the directions of the project. Being able to see the message sent between the server and client in terms of debugging purposes helped a lot with understanding where our code logic and threads were going wrong, so constantly running our ttts.c file along with the client ttt.c was very useful. The ttt file was also helpful since we were able to read and write from and to the server, and these messages were always checked. We also made it so that the client code could be changed in some way and the game would still function, which reassured that the server functionality was still there. Overall, this project was an enjoyable experience, and a great way to end off the Systems Programming Projects!